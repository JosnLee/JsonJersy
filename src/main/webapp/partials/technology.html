<div class="technology">
    <h2 class="app-title">
        <span class="title-name">
            <span class="name">技术学习</span>
        </span>
        <span class="title-description"><strong>学习项目中用到的技术</strong></span>
    </h2>
    <tabs>
        <!-- 技术雷达 -->
        <pane heading="技术雷达">
            <header class="title">
                <h3 class="title">技术雷达</h3>
                <p class="title-description"></p>
            </header>
            <div class="tech-radar">
                <div class="tech-stack-client">
                    <div class="tech-stand"><span class="stand">Client</span></div>
                    <div class="tech-stack">HTML5/CSS3/JavaScript</div>
                    <div class="tech-practise">Unit Test, Functional Test</div>
                </div>
                <div class="tech-stack-server-rest">
                    <div class="tech-stand"><span class="stand">REST</span></div>
                    <div class="tech-stack">Jersey,Guice</div>
                    <div class="tech-practise">Domain Design, Unit Test</div>
                </div>
                <div class="tech-stack-server-hibernate">
                    <div class="tech-stand"><span class="stand">JPA</span></div>
                    <div class="tech-stack">Hibernate</div>
                    <div class="tech-practise">Integration Test</div>
                </div>
                <div class="tech-stack-db">
                    <div class="tech-stand"><span class="stand">DB</span></div>
                    <div class="tech-stack">Oracle,MySQL</div>
                    <div class="tech-practise">DB Migration</div>
                </div>
            </div><!-- End tech-radar -->
        </pane>

        <!-- HTML5 -->
        <pane heading="HTML5">
            <header class="title">
                <h3 class="title">HTML5</h3>
                <p class="title-description">FTP文档：<a href="ftp://132.147.68.178/documents/学习/HTML/HTML5-Visual-Cheat-Sheet1.pdf" target="_blank">ftp://132.147.68.178/documents/学习/HTML/HTML5-Visual-Cheat-Sheet1.pdf</a></p>
            </header>
            <ul>
                <li><a href="ftp://132.147.68.178/documents/学习/HTML/HTML5-Visual-Cheat-Sheet1.pdf" target="_blank">ftp://132.147.68.178/documents/学习/HTML/HTML5-Visual-Cheat-Sheet1.pdf</a></li>
                <li><a href="ftp://132.147.68.178/documents/学习/编写高质量代码--Web前端开发修炼之道(完整).pdf" target="_blank">ftp://132.147.68.178/documents/学习/编写高质量代码--Web前端开发修炼之道(完整).pdf</a></li>
                <li><a href="ftp://132.147.68.178/documents/学习/HTML5与CSS3权威指南.pdf" target="_blank">ftp://132.147.68.178/documents/学习/HTML5与CSS3权威指南.pdf</a></li>
            </ul>
            <p>
                HTML5页面布局，请参见源代码（mock文件夹下）的布局：<a href="https://132.147.68.178/svn/sourcecode/heren-master/heren-main/mockup/ui/demo" target="_blank">https://132.147.68.178/svn/sourcecode/heren-master/heren-main/mockup/ui/demo</a>
            </p>
        </pane>

        <!-- CSS3 -->
        <pane heading="CSS3">
            <header class="title">
                <h3 class="title">CSS3</h3>
                <p class="title-description">
                    FTP文档：<a href="ftp://132.147.68.178/documents/学习/CSS/css_cheatsheet_v2.pdf" target="_blank">ftp://132.147.68.178/documents/学习/CSS/css_cheatsheet_v2.pdf</a>,
                </p>
            </header>
            <ul>
                <li><a href="ftp://132.147.68.178/documents/学习/编写高质量代码--Web前端开发修炼之道(完整).pdf" target="_blank">ftp://132.147.68.178/documents/学习/编写高质量代码--Web前端开发修炼之道(完整).pdf</a></li>
                <li><a href="ftp://132.147.68.178/documents/学习/HTML5与CSS3权威指南.pdf" target="_blank">ftp://132.147.68.178/documents/学习/HTML5与CSS3权威指南.pdf</a></li>
                <li><a href="ftp://132.147.68.178/documents/学习/CSS/css_cheatsheet_v2.pdf" target="_blank">ftp://132.147.68.178/documents/学习/CSS/css_cheatsheet_v2.pdf</a></li>
                <li><a href="ftp://132.147.68.178/documents/学习/CSS/[CSS实战手册.第2版].(美)麦克法兰.中文扫描版[ED2000.COM].pdf" target="_blank">ftp://132.147.68.178/documents/学习/CSS/[CSS实战手册.第2版].(美)麦克法兰.中文扫描版[ED2000.COM].pdf</a></li>
                <li>Bootstrap（项目中使用的CSS样式库，被整合到heren-v1.css中）：<a href="http://www.bootcss.com/" target="_blank">http://www.bootcss.com/</a>(Bootstrap2)</li>
            </ul>
        </pane>

        <!-- JavaScript -->
        <pane heading="JavaScript">
            <header class="title">
                <h3 class="title">JavaScript</h3>
                <p class="title-description">建议阅读书目：<a href="ftp://132.147.68.178/documents/JavaScript高级程序设计（第3版）.pdf" target="_blank">ftp://132.147.68.178/documents/JavaScript高级程序设计（第3版）.pdf</a></p>
            </header>
            <ul>
                <li><a href="ftp://132.147.68.178/documents/JavaScript高级程序设计（第3版）.pdf" target="_blank">ftp://132.147.68.178/documents/JavaScript高级程序设计（第3版）.pdf</a></li>
                <li>源代码：<a href="ftp://132.147.68.178/documents/Professional JavaScript for Web Developer_download.zip" target="_blank">ftp://132.147.68.178/documents/Professional JavaScript for Web Developer_download.zip</a></li>
                <li><a href="ftp://132.147.68.178/documents/电子书/JavaScript语言精粹(中+英文版).zip" target="_blank">ftp://132.147.68.178/documents/电子书/JavaScript语言精粹(中+英文版).zip</a></li>
                <li><a href="ftp://132.147.68.178/documents/电子书/[悟透JavaScript].李战.文字版(ED2000.COM).pdf" target="_blank">ftp://132.147.68.178/documents/电子书/[悟透JavaScript].李战.文字版(ED2000.COM).pdf</a></li>
                <li><a href="https://132.147.68.178/svn/dh2011/新军字一号技术培训/JavaScript语言以及jQuery、AngularJS框架.ppt" target="_blank">https://132.147.68.178/svn/dh2011/新军字一号技术培训/JavaScript语言以及jQuery、AngularJS框架.ppt</a></li>
                <li>在使用IntelliJ来Debug JavaScript： <a href="https://132.147.68.178/svn/dh2011/培训及总结/练习总结/IntelliJ中使用JavaScript Debug的步骤-王士江.doc" target="_blank">https://132.147.68.178/svn/dh2011/培训及总结/练习总结/IntelliJ中使用JavaScript Debug的步骤-王士江.doc</a></li>
            </ul>
            <p>
                按照传统的做法，所有&lt;script&gt;元素都应该放在页面的&lt;head&gt;元素中（注：项目中不这样使用），例如：
            </p>
<pre class="prettyprint">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Example HTML Page&lt;/title&gt;
    &lt;script type="text/javascript" src="example1.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript" src="example2.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!-- 这里放内容--&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
                <p>这种做法的目的就是把所有外部文件（包括CSS文件和JavaScript文件）的引用都放在相同的地方。</p>
                <p>
                    可是，在文档的&lt;head&gt;元素中包含所有JavaScript文件，意味着必须等到全部JavaScript代码都被下载、解析和执行完成以后，才能开始呈现页面的内容（浏览器在遇到&lt;body&gt;标签时才开始呈现内容）。对于
            那些需要很多JavaScript代码的页面来说，这无疑会导致浏览器在呈现页面时出现明显的延迟，而延迟
            期间的浏览器窗口中将是一片空白。为了避免这个问题，现代Web应用程序一般都把全部JavaScript引
            用放在&lt;body&gt;元素中页面内容的后面（注：项目中要这样使用），如下例所示：
                </p>
<pre class="prettyprint">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Example HTML Page&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!-- 这里放内容--&gt;
&lt;script type="text/javascript" src="example1.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="example2.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
                <p>这样，在解析包含的JavaScript代码之前，页面的内容将完全呈现在浏览器中。而用户也会因为浏览器窗口显示空白页面的时间缩短而感到打开页面的速度加快了。</p>
        </pane>

        <!-- jQuery -->
        <pane heading="jQuery">
            <header class="title">
                <h3 class="title">jQuery</h3>
                <p class="title-description">SVN API文档：<a href="https://132.147.68.178/svn/dh2011/开发文档/jQuery api 1.8 中文版.chm" target="_blank">https://132.147.68.178/svn/dh2011/开发文档/jQuery api 1.8 中文版.chm</a></p>
            </header>
            <p>
                SVN API文档：<a href="https://132.147.68.178/svn/dh2011/开发文档/jQuery api 1.8 中文版.chm" target="_blank">https://132.147.68.178/svn/dh2011/开发文档/jQuery api 1.8 中文版.chm</a><br/>
                <a href="https://132.147.68.178/svn/dh2011/新军字一号技术培训/JavaScript语言以及jQuery、AngularJS框架.ppt" target="_blank">https://132.147.68.178/svn/dh2011/新军字一号技术培训/JavaScript语言以及jQuery、AngularJS框架.ppt</a>
            </p>
        </pane>

        <!-- AngularJS -->
        <pane heading="AngularJS">
            <header class="title">
                <h3 class="title">AngularJS</h3>
                <p class="title-description">
                    中文官方网站：<a href="http://www.ngnice.com/" target="_blank">http://www.ngnice.com/</a><br/>
                    <a href="https://132.147.68.178/svn/dh2011/新军字一号技术培训/JavaScript语言以及jQuery、AngularJS框架.ppt" target="_blank">https://132.147.68.178/svn/dh2011/新军字一号技术培训/JavaScript语言以及jQuery、AngularJS框架.ppt</a>
                </p>
            </header>
            <p>
                FTP文档地址：<a href="ftp://132.147.68.178/documents/AngularJS/OReilly AngularJS En.pdf" target="_blank">ftp://132.147.68.178/documents/AngularJS/OReilly AngularJS En.pdf</a><br/>
                FTP文档目录：<a href="ftp://132.147.68.178/documents/AngularJS" target="_blank">ftp://132.147.68.178/documents/AngularJS</a><br/>
                文档地址：<a href="ftp://132.147.68.178/documents/AngularJS/OReilly AngularJS En.pdf" target="_blank">ftp://132.147.68.178/documents/AngularJS/OReilly AngularJS En.pdf</a><br/>
                文档地址:<a href="https://132.147.68.178/svn/dh2011/新军字一号技术培训/JavaScript语言以及jQuery、AngularJS框架.ppt" target="_blank">https://132.147.68.178/svn/dh2011/新军字一号技术培训/JavaScript语言以及jQuery、AngularJS框架.ppt</a><br/>
                示例源代码：<a href="https://132.147.68.178/svn/dh2011/培训及总结/练习总结示例源码/angularjs-directive.zip" target="_blank">https://132.147.68.178/svn/dh2011/培训及总结/练习总结示例源码/angularjs-directive.zip</a><br/>
                视频：<a href="ftp://132.147.68.178/trainingVideo/AngularJs/" target="_blank">ftp://132.147.68.178/trainingVideo/AngularJs/</a><br/>
            </p>
            <div class="websites">
                <h4>常用网址</h4>
                <ul class="unstyled">
                    <li>AngularJS官网: <a target="_blank" href="http://docs.angularjs.org/api/">http://docs.angularjs.org/api/</a> </li>
                    <li>AngularJS本地: <a target="_blank" href="http://132.147.68.172:8081/angular-guide-zh">http://132.147.68.172:8081/angular-guide-zh</a> </li>
                    <li>AngularJS中文: <a target="_blank" href="http://www.angularjs.cn/">http://www.angularjs.cn/</a> </li>
                    <li>AngularJS中文: <a target="_blank" href="http://www.ngnice.com/">http://www.ngnice.com/</a> </li>
                    <li>Understanding Directives: <a target="_blank" href="https://github.com/angular/angular.js/wiki/Understanding-Directives">https://github.com/angular/angular.js/wiki/Understanding-Directives</a></li>
                    <li>Understanding Scopes: <a target="_blank" href="https://github.com/angular/angular.js/wiki/Understanding-Scopes">https://github.com/angular/angular.js/wiki/Understanding-Scopes</a> </li>
                    <li>Understanding Dependency Injection: <a target="_blank" href="https://github.com/angular/angular.js/wiki/Understanding-Dependency-Injection">https://github.com/angular/angular.js/wiki/Understanding-Dependency-Injection</a> </li>
                    <li>AngularUI: <a target="_blank" href="http://angular-ui.github.io/">http://angular-ui.github.io/</a> </li>
                    <li>UI-Bootstrap: <a target="_blank" href="http://angular-ui.github.io/bootstrap/">http://angular-ui.github.io/bootstrap/</a> </li>
                    <li>ngGrid: <a target="_blank" href="http://angular-ui.github.io/ng-grid/">http://angular-ui.github.io/ng-grid/</a> </li>
                    <li>Select2: <a target="_blank" href="http://ivaynberg.github.io/select2/">http://ivaynberg.github.io/select2/</a> </li>
                </ul>
            </div>
        </pane>

        <!-- Java 7 -->
        <pane heading="Java 7">
            <header class="title">
                <h3 class="title">Java 7</h3>
                <p class="title-description">官方网站:<a href="http://docs.oracle.com/javase/7/docs/" target="_blank">http://docs.oracle.com/javase/7/docs/</a></p>
            </header>
            <p>
                官方网站:<a href="http://docs.oracle.com/javase/7/docs/" target="_blank">http://docs.oracle.com/javase/7/docs/</a>
            </p>
        </pane>

        <!-- Jersey -->
        <pane heading="Jersey">
            <header class="title">
                <h3 class="title">Jersey</h3>
                <p class="title-description">
                    官方教程地址：<a href="https://jersey.java.net/documentation/1.18/user-guide.html" target="_blank">https://jersey.java.net/documentation/1.18/user-guide.html</a><br/>
                    本地SVN教程翻译：<a href="https://132.147.68.178/svn/dh2011/培训及总结/练习总结/Jersey学习参考-王士江.doc" target="_blank">https://132.147.68.178/svn/dh2011/培训及总结/练习总结/Jersey学习参考-王士江.doc</a>
                </p>
            </header>
            <p>
                官方教程地址：<a href="https://jersey.java.net/documentation/1.18/user-guide.html" target="_blank">https://jersey.java.net/documentation/1.18/user-guide.html</a><br/>
                本地SVN教程翻译：<a href="https://132.147.68.178/svn/dh2011/培训及总结/练习总结/Jersey学习参考-王士江.doc" target="_blank">https://132.147.68.178/svn/dh2011/培训及总结/练习总结/Jersey学习参考-王士江.doc</a><br/>
                示例源代码(需要安装Maven):<a href="https://132.147.68.178/svn/dh2011/培训及总结/练习总结示例源码/jersey-test-for-maven.zip" target="_blank">https://132.147.68.178/svn/dh2011/培训及总结/练习总结示例源码/jersey-test-for-maven.zip</a>
                最佳实践：<a href="https://132.147.68.178/svn/dh2011/开发文档/开发规范/REST最佳实践.docx" target="_blank">https://132.147.68.178/svn/dh2011/开发文档/开发规范/REST最佳实践.docx</a><br/>
                JAXB注解（JSON序列化/反序列化相关）：<a href="https://132.147.68.178/svn/dh2011/开发文档/开发规范/由Jackson注解转JAXB注解备忘.doc" target="_blank">https://132.147.68.178/svn/dh2011/开发文档/开发规范/由Jackson注解转JAXB注解备忘.doc</a><br/>
                JAXB API：<a href="ftp://132.147.68.178/documents/jaxb-ri-2.2.6.zip" target="_blank">ftp://132.147.68.178/documents/jaxb-ri-2.2.6.zip</a><br/>
            </p>
            <p>
                随着REST的出现，Java社区进程执行委员会（Java Community Process, JCP）启动了JAX-RS项目，目的是为REST风格的Java Web服务创建应用编程接口。这套API也常被称呼为<strong>JAX-311</strong>或者<strong>JAX-RS</strong>。
            </p>
            <p>
                Jersey是JAX-RS 1.1规范的参考实现(Jersey the JAX-RS 1.1 reference implementation)。参考实现（reference implementation）是指囊括了某个指定规范（particular specification）所有要求（all the requirements）的实现。参考实现并不是从产品的性能角度出发的，因为它们必须大致地实现每一个细节。即便如此，Jersey也仍然是部署REST化Web服务的一个可靠选择。
            </p>
            <p>
                JAX-RS规范制定者（JAX-RS group）的目标之一是提供一个与容器无关（container agnostic）的规范，所以Jersey可以在任何Java EE容器上工作。
            </p>
            <h3>1、根资源类（Root Resource Classes)</h3>
            <h4>@Path</h4>
            <p><code>@Path</code>注解用来指定资源的相对URI路径，可以在<code>类</code>和<code>方法</code>上使用。</p>
            <p>
                <strong>URI路径模版（URI path template）</strong>是指在定义的URI中内嵌了<strong>变量</strong>（variables）的URI，只有匹配符合该URI模版的请求，才会交由其处理。这些变量将会在运行时刻、在响应发往该资源的请求时被替换。变量用<strong>花括号（curly braces）</strong>(即“{”和“}”)来定义。
            </p>
            <p>
                例如： <code>@Path(“/users/{username}”) </code>
                在这个例子中，用户将会被提示输入自己的名字，接着一个用来接受这种URI 路径模版的Jersey web服务将会被用来做出响应。假如这个用户输入的名字是“Galileo”，这个Web服务将会对如下的URL做出响应：
               <code> http://example.com/users/Galileo  </code>
            </p>
            <p>
                为了得到<code>username</code>变量上的值，可以通过在请求的资源方法的参数上使用<code>@PathParam</code>。
            </p>
<pre class="prettyprint">
/**指定URI路径上的参数：*/
@Path(“/users/{username}”)
public class UserResource {
  @GET
  @Produces(“text/xml”)
  public String getUser(@PathParam(“username”) String username) {
               ... ...
  }
}
</pre>
            <p>
                一个<code>@Path</code>的值既可以使用、也可以不使用“/”作为开始，这都没有造成什么不同。同样地，默认情况下@Path的值既可以使用、
                也可以不使用“/”作为结尾，这也不会造成什么不同，因此，不管请求的URL是不是以“/”结尾都会被匹配上。
                然而，Jersey有一个重定向机制（redirection mechanism），假设该机制被启用，如果某个请求的URL没有以“/”作为结尾，
                Jersey将会自动重定向到一个以“/”作为结尾的URL上，该匹配的@Path需要以一个“/”作为结尾。
            </p>
            <h4>根资源类（Root resource classes）</h4>
            <p>
                   根资源类（Root resource classes）是用<code>@Path</code>注解进行标注的POJO（Plain Old Java Object，普通老式爪哇对象），
                   类里面至少需要有一个被@Path注解的方法，或者被@GET、@PUT、@POST、DELETE等资源方法标识符（resource method designator）注解的方法。
            </p>
<pre class="prettyprint">
@GET
@Produces("application/xml")
public Item get() { ... }
}
</pre>

            <h4>子资源方法（Sub resource methods）</h4>
            <p>
                子资源方法（sub resource methods）是指在一个资源类中、用资源方法标识符（resource method designator,如@GET、@PUT、@POST、DELETE等）注解的方法。
            </p>
            <h3>子资源定位器（Sub-resource locator）</h3>
               <p>

                   子资源定位器（sub-resource locators）是指那些使用@Path注解、而且没有被资源方法标识符（resource method designator,如@GET、@PUT、@POST、DELETE等）注解的方法。例如：
            </p>
<pre class="prettyprint">
@Path("/item")
public class ItemResource {
    @Context UriInfo uriInfo;

    @Path("content")
    public ItemContentResource getItemContentResource() {
        return new ItemContentResource();
    }

    public class ItemContentResource {
    @GET
    public Response get() { ... }

    @PUT
    @Path("{version}")
    public void put(@PathParam("version") int version,
        @Context HttpHeaders headers,
        byte[] in) {
    }
}
</pre>
            <p>
                另外，处理子资源定位器的资源类是在运行时，因此可以使用多态。一个子资源定位器可以根据请求的不同返回不同的子类型（例如，子资源定位器可以根据角色权限的不同，来返回不同的子类型）。
                需要注意的是，运行时不会管理返回子资源定位器实例的生命周期和字段的依赖注入（filed injection）。这是因为运行时不知道这个实例的生命周期是什么样。
            </p>
            <p>
            <h4>@Path变量上的正则表达式</h4>
            <p>
                在路径变量上，可以通过使用<strong>正则表达式（regular expression）</strong>，来限制URI所能获取的值。默认的正则表达式是<code>”[^/]+?”</code>（不包括斜杠的至少一个或多个字符，匹配尽可能少的字符）
            </p>
            <h4>根资源类的生命周期</h4>
            <p>
            默认情况下，根资源的生命周期是基于每一次的请求的，也就是说根资源类在<strong>每次URI路径匹配时会被实例化一次</strong>。这是一种常用的编程模型，这样构造器和字段就可以直接拿来就用，而不用多个请求访问同一资源考虑多线程问题。
            总体来说，这不会造成性能问题。类的构造以及JVM的垃圾回收在最近几年已经得到了大幅度地性能提升，服务器端可以更频繁地创建对象和舍弃对象，以便处理HTTP请求和做出响应。
            单例的根资源可以通过在Application中进行声明来实现。
            Jersey通过特定的注解（Jersey specific annotations）来支持两种更进一步的生命周期。如果一个根资源类被<code>@Singleton</code>注解，那么这个根资源类将会在整个Web应用中存在一个实例。如果一个根资源类被<span style="color: blue">@PerSession</span>注解，那么根资源类就会在每一次的web会话（web session）中被创建一次，以一个会话的属性存在。
            </p>
            <h3>参数抽取（Extracting Request Parameters）</h3>
            <p>
                资源方法的参数可以通过使用基于参数的注解（parameter-based annotations）来抽取请求中的相应的信息。
                基于参数的注解：<code>@PathParam，@QueryParam，@MatrixParam，@HeaderParam，@CookieParam，@FormParam</code>。总的来说，用做方法的参数的Java类型可以是：
            </p>
            <ul class="unstyled">
                <li><b>①基本类型</b> （即包括int 、long、boolean等在内8个基本类型）；</li>
                <li><b>②引用类型</b>——拥有一个可以接受单个String类型参数的有参数构造器；</li>
                <li><b> ③引用类型</b>——拥有一个静态方法valueOf或fromString，在方法中可以接受单个String参数（例如，Integer.valueOf(String) 以及java.util.UUID.fromString(String)）；</li>
                <li><b>④是List&lt;T&gt;，Set&lt;T&gt;或者SortedSet&lt;T&gt;</b>，这里的T符合（2）和（3）中的条件。形成的集合（collection）对象是只读的。</li>
            </ul>
            <p>
                如果@DefaultValue没有跟<b>@QueryParam</b>组合使用，而且查询所用的参数不在本次请求之中，那么参数的默认值将会是：对于List，Set或SortedSet来说，是空的集合（empty collection）；
                对于其他的对象类型（object types）来说，是null；对于基本类型来说，是Java定义的默认值（boolean是false，数值型是0，char是’\u0000’）。
            </p>
            <p>
                <b><u>（1）@PathParam</u></b><br/>
                在前面的例子中，我们是通过使用@PathParam注解来抽取请求的URL中匹配@Path路径中定义的变量信息。
                <b><u>（2）@QueryParam </u></b><br/>
                @QueryParam用来抽取请求的URL中查询部分（Query component）的参数信息<br/>
                <b><u>（3）@DefaultValue</u></b><br/>
                使用@DefaultValue来设置参数的默认值<br/>
                <b><u>（4）@FormParam</u></b><br/>
                @FormParam有一些特殊，因为它抽取是请求中的MIME媒体类型为“application/x-www-form-urlencoded”的表现，由HTML的表单来遵守和使用。这个注解对于抽取由HTML表单提交的POST请求中的信息非常有用。
                <b><u>（5）@FormDataPara</u></b><br/>
                @FormDataParam用于绑定一个“multipart/form-data”类型的请求实体，抽取指定名称的内容（body part）用来作为一个资源方法的参数。
                @FormParam注解与媒体类型（media type）“application/x-www-form-urlencoded”组合使用，对于发送（send）和接收（consume）大数量的二进制数据、以及非ASCII（non-ASCII）字符文本效率是很低的。
                而应该使用@FormDataParam与媒体类型“multipart/form-data”的组合，来处理包含文件（files）、非ASCII数据（non-ASCII data）、以及二进制数据（binary data）。
                作为@FormDataParam注解的参数的类型（type T）必须是：
                ①FormDataBodyPart。参数的值将是第一个匹配上该命名的数据实体部分（the first named body part）；其他情况下，如果该命名的数据实体部分不存在，则返回null。
                ②FormDataBodyPart的一个列表（list）或集合（collection）。参数的值将是一个或多个具有相同命名的数据实体部分（one or more named body parts with the same name）；其他情况下，如果该命名的数据实体部分不存在，则返回null。
                ③FormDataContentDisposition。参数的值将是第一匹配上的该命名的数据实体部分的内容配置（the content disposition of the first named body part）；其他情况下，如果该命名的数据实体部分不存在，则返回null。
                ④FormDataContentDisposition的一个列表（list）或集合（collection）。参数的值将是一个或多个具有相同名称的数据实体部分（body part）的内容配置；其他情况下，如果该命名的数据实体部分不存在，则返回null。
                ⑤拥有给定类型消息体reader的类型（A type for which a message body reader is available given the media type of the first named body part）。 参数的值将会是从消息体中读取后的该类型的一个实例（The value of the parameter will be the result of reading using the message body reader given the type T）,包括媒体类型的命名部分（the media type of the named part）,而且以数据实体的字节表示作为输入（and the bytes of the named body part as input）。
            </p>

            <p>
                3、HTTP方法（HTTP Methods）<br/>
                @GET、@PUT、@POST、@DELETE和@HEAD是JAX-RS定义的资源方法标识符注解（resource method designator annotations），跟同名的HTTP方法一一对应。该资源的行为由响应时使用的是哪一个HTTP方法决定。<br>
                （1）@GET<br/>
                The method GET is used to RETRIEVE resources.
                GET方法用来获取（RETRIEVE）资源。</br>
                （2）@PUT <br/>
                The method PUT is used to UPDATE resources.
                PUT方法用来更新资源。<br/>
                （3）@POST<br/>
                The method POST is used to CREATE resources.
                POST方法用来创建资源。<br/>
                一个常用的RESTful 模式是在响应一个POST请求、创建一个新资源时，返回一个201状态码（Created，已创建），然后在报文头的Location上添加新创建的资源的URI。<br>
                （4）@DELETE<br/>
                The method DELETE is used to DELETE representations.
                DELETE方法用来删除资源。<br>
            </p>
            <p>
                @Produces和Consumes<br>
                （1）@Produces<br>
                @Produces注解用来指定服务器能够产生的、向客户端发送的MIME媒体类型。
                @Produces可以应用在类和方法上。
                如果一个资源类能够产生不止一个MIME媒体类型，那么使用哪一个资源方法进行响应将由客户端声明的更倾向于接受的媒体类型所决定。更进一步地说，由HTTP请求的Accept头（Accept header）来声明更接受的请求类型。
                <br>例如，下面有一个Accept头：
                Accept: text/plain
                那么产生纯文本类型的方法将会被调用。
                如果有一个Accept头如下所示：<br>
                Accept: text/plain;q=0.9, text/html
                表明客户端声明可以接受的媒体类型是“text/plain”和“text/html”，不过更倾向于后者，那么产生HTML类型的方法将会被调用。<br>
                在@Produces中声明了不止一个媒体类型，如下所示：
            <p>
<pre class="prettyprint">
@GET
@Produces({"application/xml", "application/json"})
public String doGetAsXmlOrJson() {
    ... ...
}
</pre>
            <p>
                这样，如果客户端可接受的媒体类型是“application/xml”和“application/json”，那么doGetAsXmlOrJson方法将会被调用。如果这两种媒体类型客户端都一样支持，那么第一个媒体类型将会被选中，因为它是第一个出现的。
                上面的MIME类型都明确地写明了，为了避免错误，最好使用MIME常量（constant value），这样可以避免录入错误，请参见MediaType中的常量字段。
            </p>
            <p>
                （2）@Consumes<br>
                @Consumes注解用来指定可以消费的从客户端发过来的MIME媒体表现（MIME media types of representations）。例如：
            </p>
<pre class="prettyprint">
@POST
@Consumes(“text/plain”)
public void postClichedMessage(String message) {
    ... ...
}
</pre>
            <p>
                在这个例子中，这个Java方法将会消费MIME类型为“text/plain”的表现。请注意，这个资源方法返回了一个void，这表示不会返回任何内容，这样一个状态码为204(No Content，没有内容)将会被返回。
                @Consumes可以用在类级别和方法级别上，可以在一个@Consumes中声明不止一个媒体类型。

            </p>
            <p>
                表现（Representations）和Java类型（Java Types)<br>
                诸如byte[]、java.io.InputStream、java.io.Reader和java.io.File等Java类型都被支持。另外JAXB bean也被支持。这些bean是JAXBElement，或者说是用@XmlRootElement或@XmlType注解的类。
                不像抽取请求参数的方法参数那样，跟表现（representation）结合的方法参数在使用时不要求使用注解。最多有一个没被注解的方法参数存在，因为一个请求至多只有发送一个表现（representation）。
            </p>
<pre class="prettyprint">
@GET
@Path("/images/{image}")
@Produces("image/*")
public Response getImage(@PathParam("image") String image) {
	if (!isSafeToOpenFile(image)) {
		throw new IllegalArgumentException("Cannot open the image file.");
	}

	File f = new File(image);

	if (!f.exists()) {
		throw new WebApplicationException(404);
	}

	String mt = new MimetypesFileTypeMap().getContentType(f);
	return Response.ok(f, mt).build();
}
</pre>
        <p>
            一个文件类型（File type）可以用来作为参数，这时一个临时文件会在请求实体加载完毕时被创建。
        </p>
        <p>
            创建响应（Building Responses）<br>
            许多情况下需要在HTTP请求的响应中添加一些额外的信息。这些信息可以通过使用Response和Response.ResponseBuilder来创建。例如，一个常用的RESTful 模式是在响应一个POST请求、创建一个新资源时，返回一个201状态码（Created，已创建），然后在报文头的Location上添加新创建的资源的URI。例如：
        </p>
<pre class="prettyprint">
@POST
@Consumes("application/xml")
public Response post(String content) {
  URI createdUri = ...
  create(content);
  return Response.created(createdUri).build();
}
</pre>
        <p>
            上面的情况下，没有任何表现被创建，可以通过如下方式向将一个实体（entity）作为响应的一部分：
        </p>

<pre class="prettyprint">
@POST
@Consumes("application/xml")
public Response post(String content) {
    URI createdUri = ...
    String createdContent = create(content);
    return Response.created(createdUri).entity(createdContent).build();
}
</pre>
        <p>
            创建URI（Building URIs）<br>
            REST的一个非常重要的方面是超链接，URIs，放在各种表现中（representations），使得客户端能够转移Web服务到一个新的应用状态（这就是有名的“hypermedia as the engine of application state”，超媒体作为应用状态的引擎）。HTML的Form表单是这方面的一个非常好的实现。
            使用java.net.URI来创建URI并不容易，这就是为什么JAX-RS多出一个UriBuilder类使得创建URI又简单、又安全。
            UriBuilder可以用来创建新的URI，或者从已存在的URI来创建。对于资源类来说，更倾向于从web服务部署的基本URI（base URI）中来创建新的URI，或者从请求的URI中来创建。UriInfo类提供了这方面的信息。
            如下所示：
        <p>
<pre class="prettyprint">
@Path("/users/")
public class UsersResource {

    @Context UriInfo uriInfo;

    ...

    @GET
    @Produces("application/json")
    Public  JSONArray  getUsersAsJsonArray() {
        JSONArray uriArray = new JSONArray();
        for (UserEntity userEntity : getUsers()) {
            UriBuilder ub = uriInfo.getAbsolutePathBuilder();
            URI userUri = ub.path(userEntity.getUserid()).build();
            uriArray.put(userUri.toASCIIString());
        }
        return uriArray;
    }
}
</pre>
        <p>
            UriInfo通过使用@Context注解被获得，在上面的例子中，被注入到根资源的成员字段中。<br/>
            UriInfo可以用来获得URI及其相关的UriBuilder实例：像应用部署的基本URI；请求的URI；绝对路径URI（即不包括参数的请求URI）。<br/>
            UriBuilder可以用来构建/替换请求参数（request parameters）或矩阵参数（matrix parameters）。URI模版也可以被声明，例如，接下来将会构建一个“http://localhost/segment?name=value”的URI：<br/>
        </p>

<pre class="prettyprint">
UriBuilder.fromUri("http://localhost/").
path("{a}").
queryParam("name", "{value}").
build("segment", "value");
</pre>
        </p>
        </pane>

        <!-- Guice -->
        <pane heading="Guice">
            <header class="title">
                <h3 class="title">Guice</h3>
                <p class="title-description">
                    SVN文档：<a href="https://132.147.68.178/svn/dh2011/培训及总结/练习总结/Dependency Injection学习-曾川.docx" target="_blank">https://132.147.68.178/svn/dh2011/培训及总结/练习总结/Dependency Injection学习-曾川.docx</a>
                </p>
            </header>
            <p>
                FTP文档：<a href="ftp://upload@132.147.68.178/documents/[itpub.net]Apress.Google.Guice.Agile.Lightweight.Dependency.Injection.Framework.Apr.2008.pdf" target="_blank">ftp://132.147.68.178/documents/[itpub.net]Apress.Google.Guice.Agile.Lightweight.Dependency.Injection.Framework.Apr.2008.pdf</a><br/>
                SVN文档：<a href="https://132.147.68.178/svn/dh2011/培训及总结/练习总结/Dependency Injection学习-曾川.docx" target="_blank">https://132.147.68.178/svn/dh2011/培训及总结/练习总结/Dependency Injection学习-曾川.docx</a><br/>
                SVN示例源代码：<a href="https://132.147.68.178/svn/dh2011/培训及总结/练习总结示例源码/zengchuan-guice.rar" target="_blank">https://132.147.68.178/svn/dh2011/培训及总结/练习总结示例源码/zengchuan-guice.rar</a><br/>
                官网地址：<a href="http://code.google.com/p/google-guice/wiki/ProvidesMethods" target="_blank">http://code.google.com/p/google-guice/wiki/ProvidesMethods</a><br/>
            </p>
            <p>
                <code>@Inject</code>注解的使用方法：
            </p>
            <p class="comment-img">
                <img src="ext/technology/google-guice-inject-constructor.jpg"/>
            </p>
            <p class="comment-img">
                <img src="ext/technology/google-guice-inject-field.jpg"/>
            </p>
        </pane>

        <!-- JPA -->
        <pane heading="JPA">
            <header class="title">
                <h3 class="title">JPA</h3>
                <p class="title-description">
                    SVN文档：<a href="https://132.147.68.178/svn/dh2011/培训及总结/练习总结/JPA2.0-陶磊.docx" target="_blank">https://132.147.68.178/svn/dh2011/培训及总结/练习总结/JPA2.0-陶磊.docx</a>
                </p>
            </header>
            <p>
                SVN文档：<a href="https://132.147.68.178/svn/dh2011/培训及总结/练习总结/JPA2.0-陶磊.docx" target="_blank">https://132.147.68.178/svn/dh2011/培训及总结/练习总结/JPA2.0-陶磊.docx</a><br/>
                FTP文档：<a href="ftp://132.147.68.178/documents/学习/[Pro.JPA2中文版：精通Java持久化API].(基恩等).巢文涵.扫描版(ED2000.COM).pdf" target="_blank">ftp://132.147.68.178/documents/学习/[Pro.JPA2中文版：精通Java持久化API].(基恩等).巢文涵.扫描版(ED2000.COM).pdf</a>
            </p>
        </pane>

        <!-- SQL -->
        <pane heading="SQL">
            <header class="title">
                <h3 class="title">SQL</h3>
                <p class="title-description">
                    FTP文档：<a href="ftp://132.147.68.178/documents/电子书/SQL完全手册.pdf" target="_blank">ftp://132.147.68.178/documents/电子书/SQL完全手册.pdf</a><br/>
                    Flyway官网：<a href="http://flywaydb.org/" target="_blank">http://flywaydb.org/</a>
                </p>
            </header>
            <p>
                FTP文档：<a href="ftp://132.147.68.178/documents/电子书/SQL完全手册.pdf" target="_blank">ftp://132.147.68.178/documents/电子书/SQL完全手册.pdf</a><br/>
                Flyway官网：<a href="http://flywaydb.org/" target="_blank">http://flywaydb.org/</a><br/>
                Flyway相关文档:<a href="https://132.147.68.178/svn/dh2011/新军字一号技术培训/JavaScript语言以及jQuery、AngularJS框架.ppt" target="_blank">https://132.147.68.178/svn/dh2011/新军字一号技术培训/JavaScript语言以及jQuery、AngularJS框架.ppt</a><br/>
            </p>
            <p class="comment-img">
                <img src="ext/technology/sql-db-migration.jpg"/>
            </p>
            <p>
                Flyway相关文档:<a href="https://132.147.68.178/svn/dh2011/新军字一号技术培训/JavaScript语言以及jQuery、AngularJS框架.ppt" target="_blank">https://132.147.68.178/svn/dh2011/新军字一号技术培训/JavaScript语言以及jQuery、AngularJS框架.ppt</a><br/>
            </p>
<pre class="prettyprint">
package com.heren.his;

import com.googlecode.flyway.core.Flyway;
import java.util.Properties;

/**
 * Clean Database(清空herendh用户的数据库空间).
 */
public class CleanDatabase {
    public static void main(String[] args) {
        Properties properties = new Properties();
        properties.put("flyway.driver", "oracle.jdbc.driver.OracleDriver");
        properties.put("flyway.url", "jdbc:oracle:thin:@127.0.0.1:1521:orcl");
        properties.put("flyway.user", "herendh");
        properties.put("flyway.password", "herendh");

        Flyway flyway = new Flyway();
        flyway.setValidateOnMigrate(true);
        flyway.configure(properties);
        flyway.clean();
    }
}
</pre>
        <p>
            将176数据库的herendh用户数据，导出到本地文件（）：<code>exp herendh/herendh@orcl_176 owner=herendh file=E:\oracle176\orcl-2014-07-07.dmp</code><br/>
            将之前导出的176数据，导入到本地herendh用户（导入之前先清空该用户的数据库）：<code>imp herendh/herendh@orcl fromuser=herendh touser=herendh file=E:\oracle176\orcl-2014-07-07.dmp</code>
        </p>
        </pane>

        <!-- 敏捷开发 -->
        <pane heading="敏捷开发">
            <header class="title">
                <h3 class="title">敏捷开发</h3>
                <p class="title-description">如果允许一个新手一次走两步，那么他就可以击败象棋大师。（Mark Goldenson）</p>
            </header>
            <p>
                Mark Goldenson在关闭自己创建的playcafe.com之后总结道：“如果允许一个新手一次走两步，那么他就可以击败象棋大师。”
                （A chess novice can defeat a master if moving twice each round.）
            </p>
            <p class="comment-img">
                <img src="ext/technology/traditional-vs-agile-dev.jpg"/>
            </p>
        </pane>

    </tabs>
   </div>